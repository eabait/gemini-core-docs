# 系统边界接口文档

本文档描述了系统的外部调用接口，包括CLI命令、API端点、配置参数等边界机制。

## 集成建议

### Module Import/SDK Integration

The system exposes a unified TypeScript/JavaScript entry (index.ts) that aggregates all submodules (configuration, commands, core logic, policy, telemetry, code assistance, OAuth, IDE integration, and utilities). External systems or extensions should import from this single entry-point to ensure stable dependency resolution and future-proof module composition.

**示例代码**:

```
// Example: Importing core modules from the unified entry
import { initializeTelemetry, resolveTelemetrySettings, Storage, createPolicyEngineConfig } from 'gemini-cli-core';

// Initialize telemetry
initializeTelemetry();

// Resolve settings with CLI/environment/file priority
const telemetrySettings = await resolveTelemetrySettings({ argv: { telemetry: true }, env: process.env });

// Manage storage and paths
const storage = new Storage('/project/root');
const tempDir = storage.getProjectTempDir();

// Configure or update policy engine
define async setupPolicy(settings) {
  const policyConfig = await createPolicyEngineConfig(settings, 'strict');
  // ...
}

```

**最佳实践**:

- Always refer to the main index.ts for all internal SDK submodules and types. This optimizes for code clarity, keeps dependency mapping simple, and leverages centralized version upgrades.
- For policy management and configuration, use the exported configuration classes (from config/storage and policy/config) to generate, override, and manage settings in a programmatic and validated way.
- Initialize telemetry systems explicitly using the exported functions (e.g., initializeTelemetry), and resolve runtime settings using the resolveTelemetrySettings method for consistent overrides.
- To leverage OAuth and secure credentials, always interact with the exposed OAuthProvider and credential storage APIs and avoid hardcoding credential paths.
- Apply extension loading, hook registration, and dynamic tool registration patterns using exported helpers to safely extend the system.

### Policy Management & Security

The policy/config.ts module enables dynamic and layered security and access controls via TOML policy files, runtime settings, and message-bus-based dynamic updates. External management utilities, DevOps scripts, or integrations must align with the admin/user/default policy tiers and robustly serialize/deserialize rules according to system conventions.

**示例代码**:

```
// Example: Persisting a policy rule update via the message bus
import { MessageBusType, MessageBus } from 'gemini-cli-core/confirmation-bus';

const bus = new MessageBus();
bus.publish(MessageBusType.UPDATE_POLICY, { toolName: 'dangerousTool', decision: 'deny', persist: true });

```

**最佳实践**:

- Place persistent policy TOML files in the appropriate Admin, User, or Default directories, conforming to the getPolicyDirectories and getPolicyTier conventions for layered enforcement.
- Use the message bus (confirmation-bus) to push live policy updates and persist changes automatically via provided APIs.
- Handle policy error feedbacks via the coreEvents emitter to integrate real-time UI or monitoring feedback.
- Generate and audit rules using well-defined priorities, and leverage the createPolicyUpdater and createPolicyEngineConfig for safe runtime mutation.
- Never manipulate policy directory files manually outside of defined APIs to avoid breaking the tier/priority system or TOML formatting.

### Telemetry Integration

The telemetry subsystem provides endpoints for recording, flushing, and exporting telemetry to local or GCP endpoints. External monitoring, CI/CD automation, or plugin systems must use the provided initialization, logging, and metrics APIs for proper observability.

**示例代码**:

```
// Example: Setting up and recording telemetry
import { initializeTelemetry, logApiRequest, shutdownTelemetry } from 'gemini-cli-core/telemetry';

initializeTelemetry();
logApiRequest({ endpoint: '/predict', method: 'POST' });
// ... perform actions ...
await shutdownTelemetry();

```

**最佳实践**:

- Call initializeTelemetry before any tool or API usage to record events from the start of application or extension lifecycle.
- Configure telemetry targets either programmatically or via supported environment variables (e.g., GEMINI_TELEMETRY_TARGET), and use resolveTelemetrySettings for consistent aggregation.
- Export or forward events using GcpTraceExporter, GcpMetricExporter, or file exporters for local/remote diagnostics.
- Shut down (shutdownTelemetry) or flush (flushTelemetry) before process exit for complete data delivery.
- Respect TelemetryArgOverrides to allow CLI/tools/users to control sensitivity and transmission of telemetry data.


---

**分析置信度**: 9.0/10
